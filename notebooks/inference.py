from dataclasses import dataclass

import numpy as np
from scipy import stats
from tqdm import tqdm


@dataclass
class Dist:
    loc: float
    scale: float


class Metropolis:
    def __init__(self) -> None:
        self.rng = np.random.default_rng()

    def __call__(self, n: int, observation: np.ndarray, mu_obs: float) -> list:
        trace = []  # to keep a trace

        # generate two distributions, both with a given mean and std=1
        old = Dist(mu_obs, 1)
        for _i in tqdm(range(n)):
            # make a random walk
            new = self.random_walk(old)

            # compare the probability of the two distributions,
            # given the distribution
            current = self.get_log_probs(observation, dist=old)
            proposed = self.get_log_probs(observation, dist=new)

            # if we accept the new distribution
            if self.accept(proposed, current):
                # add it to the trace, with a 1 denoting "accepted"
                trace.append([new.scale, 1])
                # replace the old distribution
                old.scale = new.scale
            else:
                # add the distribution to the trace, so we can still see
                # what values are not accepted
                # We add a 0 to be able to filter them out
                trace.append([new.scale, 0])
                # we dont swap the old distribution
        return trace

    def get_log_probs(self, observation: np.ndarray, dist: Dist) -> float:
        """receives an array of observations.
        Given a mean and std, it creates a pdf with those parameters and
        calculates for every observation, what the chance is that this value
        would have been drawn from a distribution with those parameters.

        To avoid rounding errors, instead of multiplying all values, we take
        the log and sum them all. This gives us a value we can use to compare
        different probabilities (how likely is it, that this distribution generated
        this set of observations?)

        Args:
            observation (np.ndarray): array of observations
            dist (Dist): a distribution with a mean and std

        Returns:
            float: probability that the observations are drawn from this distribution
        """
        probs = stats.norm(loc=dist.loc, scale=dist.scale).pdf(observation)  # type: ignore
        return float(np.sum(np.log(probs)))

    def random_walk(self, old: Dist) -> Dist:
        """Draw a value from a normal distribution with the old scale.
        The value we draw is the proposed standard deviation for the new scale

        Args:
            old (Dist): The current (old) Dist

        Returns:
            Dist: A Dist, generated by random walk with a new scale
        """
        scale = stats.expon.rvs(loc=0, scale=old.scale)
        return Dist(old.loc, scale)

    def accept(self, proposed: float, current: float) -> bool:
        if proposed > current:
            return True
        accept = self.rng.uniform(0, 1)
        return bool(accept < (np.exp(proposed - current)))
